name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write
  pull-requests: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - name: Generate GitHub App Token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          fetch-tags: true
          token: ${{ steps.app-token.outputs.token }}

      - name: Configure git for GitHub App
        run: |
          git config --global user.name "py-netatmo-truetemp-release-bot[bot]"
          git config --global user.email "${{ secrets.APP_ID }}+py-netatmo-truetemp-release-bot[bot]@users.noreply.github.com"

      - name: Set up Python 3.13
        uses: actions/setup-python@v6
        with:
          python-version: "3.13"

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true
          cache-dependency-glob: "uv.lock"

      - name: Install dependencies
        run: uv sync --frozen

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Semantic Release
        id: semantic
        uses: cycjimmy/semantic-release-action@v4
        with:
          extra_plugins: |
            @semantic-release/changelog
            @semantic-release/exec
            conventional-changelog-conventionalcommits
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Create Verified Release Commit and PR
        if: steps.semantic.outputs.new_release_published == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const version = '${{ steps.semantic.outputs.new_release_version }}';
            const fs = require('fs');
            const branchName = `release/v${version}`;

            console.log(`Creating release PR for version ${version}`);

            // Read updated files
            const changelog = fs.readFileSync('CHANGELOG.md', 'utf8');
            const pyproject = fs.readFileSync('pyproject.toml', 'utf8');
            const initPy = fs.readFileSync('src/py_netatmo_truetemp/__init__.py', 'utf8');

            // Get main branch commit
            const { data: mainRef } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'heads/main'
            });
            const mainSha = mainRef.object.sha;

            // Get base tree
            const { data: mainCommit } = await github.rest.git.getCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: mainSha
            });

            // Create blobs for updated files in parallel
            const [changelogBlob, pyprojectBlob, initPyBlob] = await Promise.all([
              github.rest.git.createBlob({
                owner: context.repo.owner,
                repo: context.repo.repo,
                content: Buffer.from(changelog).toString('base64'),
                encoding: 'base64'
              }),
              github.rest.git.createBlob({
                owner: context.repo.owner,
                repo: context.repo.repo,
                content: Buffer.from(pyproject).toString('base64'),
                encoding: 'base64'
              }),
              github.rest.git.createBlob({
                owner: context.repo.owner,
                repo: context.repo.repo,
                content: Buffer.from(initPy).toString('base64'),
                encoding: 'base64'
              })
            ]);

            // Create new tree
            const { data: newTree } = await github.rest.git.createTree({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base_tree: mainCommit.tree.sha,
              tree: [
                { path: 'CHANGELOG.md', mode: '100644', type: 'blob', sha: changelogBlob.data.sha },
                { path: 'pyproject.toml', mode: '100644', type: 'blob', sha: pyprojectBlob.data.sha },
                { path: 'src/py_netatmo_truetemp/__init__.py', mode: '100644', type: 'blob', sha: initPyBlob.data.sha }
              ]
            });

            // Create verified commit via GitHub API
            const { data: newCommit } = await github.rest.git.createCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              message: `chore(release): ${version} [skip ci]\n\nðŸ¤– Generated with semantic-release`,
              tree: newTree.sha,
              parents: [mainSha]
            });

            console.log(`âœ“ Created verified commit: ${newCommit.sha}`);

            // Delete branch if it exists (cleanup from previous failed runs)
            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `heads/${branchName}`
              });
              console.log(`âœ“ Deleted existing branch: ${branchName}`);
            } catch (error) {
              // Branch doesn't exist, that's fine
            }

            // Create release branch
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/heads/${branchName}`,
              sha: newCommit.sha
            });

            console.log(`âœ“ Created branch: ${branchName}`);

            // Check if PR already exists
            const { data: existingPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branchName}`,
              base: 'main',
              state: 'open'
            });

            let pr;
            if (existingPRs.length > 0) {
              pr = existingPRs[0];
              console.log(`âœ“ Found existing PR #${pr.number}: ${pr.html_url}`);
            } else {
              // Create PR
              const { data: newPR } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `chore(release): ${version}`,
                head: branchName,
                base: 'main',
                body: `Automated release PR for version ${version}\n\n## Changes\n- Updated CHANGELOG.md\n- Updated version in pyproject.toml to ${version}\n- Updated version in __init__.py to ${version}\n\n**Note**: This commit is verified by GitHub (created via API).\n\nThis PR was automatically created by the release workflow.`
              });
              pr = newPR;
              console.log(`âœ“ Created PR #${pr.number}: ${pr.html_url}`);
            }

            // Enable auto-merge via GraphQL
            const mutation = `
              mutation($prId: ID!) {
                enablePullRequestAutoMerge(input: {pullRequestId: $prId, mergeMethod: SQUASH}) {
                  pullRequest {
                    autoMergeRequest {
                      enabledAt
                    }
                  }
                }
              }
            `;

            try {
              await github.graphql(mutation, { prId: pr.node_id });
              console.log('âœ“ Auto-merge enabled');
            } catch (error) {
              console.log(`âš  Could not enable auto-merge: ${error.message}`);
              console.log('You may need to merge the PR manually');
            }

            console.log(`\nâœ“ Release PR ready: ${pr.html_url}`)
